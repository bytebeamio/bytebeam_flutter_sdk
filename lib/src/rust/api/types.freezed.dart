// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'types.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$FieldValue {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(String field0) string,
    required TResult Function(int field0) int,
    required TResult Function(bool field0) bool,
    required TResult Function(double field0) float,
    required TResult Function(List<FieldValue> field0) array,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(String field0)? string,
    TResult? Function(int field0)? int,
    TResult? Function(bool field0)? bool,
    TResult? Function(double field0)? float,
    TResult? Function(List<FieldValue> field0)? array,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(String field0)? string,
    TResult Function(int field0)? int,
    TResult Function(bool field0)? bool,
    TResult Function(double field0)? float,
    TResult Function(List<FieldValue> field0)? array,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldValue_Null value) null_,
    required TResult Function(FieldValue_String value) string,
    required TResult Function(FieldValue_Int value) int,
    required TResult Function(FieldValue_Bool value) bool,
    required TResult Function(FieldValue_Float value) float,
    required TResult Function(FieldValue_Array value) array,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldValue_Null value)? null_,
    TResult? Function(FieldValue_String value)? string,
    TResult? Function(FieldValue_Int value)? int,
    TResult? Function(FieldValue_Bool value)? bool,
    TResult? Function(FieldValue_Float value)? float,
    TResult? Function(FieldValue_Array value)? array,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldValue_Null value)? null_,
    TResult Function(FieldValue_String value)? string,
    TResult Function(FieldValue_Int value)? int,
    TResult Function(FieldValue_Bool value)? bool,
    TResult Function(FieldValue_Float value)? float,
    TResult Function(FieldValue_Array value)? array,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FieldValueCopyWith<$Res> {
  factory $FieldValueCopyWith(
          FieldValue value, $Res Function(FieldValue) then) =
      _$FieldValueCopyWithImpl<$Res, FieldValue>;
}

/// @nodoc
class _$FieldValueCopyWithImpl<$Res, $Val extends FieldValue>
    implements $FieldValueCopyWith<$Res> {
  _$FieldValueCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$FieldValue_NullImplCopyWith<$Res> {
  factory _$$FieldValue_NullImplCopyWith(_$FieldValue_NullImpl value,
          $Res Function(_$FieldValue_NullImpl) then) =
      __$$FieldValue_NullImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FieldValue_NullImplCopyWithImpl<$Res>
    extends _$FieldValueCopyWithImpl<$Res, _$FieldValue_NullImpl>
    implements _$$FieldValue_NullImplCopyWith<$Res> {
  __$$FieldValue_NullImplCopyWithImpl(
      _$FieldValue_NullImpl _value, $Res Function(_$FieldValue_NullImpl) _then)
      : super(_value, _then);

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FieldValue_NullImpl extends FieldValue_Null {
  const _$FieldValue_NullImpl() : super._();

  @override
  String toString() {
    return 'FieldValue.null_()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FieldValue_NullImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(String field0) string,
    required TResult Function(int field0) int,
    required TResult Function(bool field0) bool,
    required TResult Function(double field0) float,
    required TResult Function(List<FieldValue> field0) array,
  }) {
    return null_();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(String field0)? string,
    TResult? Function(int field0)? int,
    TResult? Function(bool field0)? bool,
    TResult? Function(double field0)? float,
    TResult? Function(List<FieldValue> field0)? array,
  }) {
    return null_?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(String field0)? string,
    TResult Function(int field0)? int,
    TResult Function(bool field0)? bool,
    TResult Function(double field0)? float,
    TResult Function(List<FieldValue> field0)? array,
    required TResult orElse(),
  }) {
    if (null_ != null) {
      return null_();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldValue_Null value) null_,
    required TResult Function(FieldValue_String value) string,
    required TResult Function(FieldValue_Int value) int,
    required TResult Function(FieldValue_Bool value) bool,
    required TResult Function(FieldValue_Float value) float,
    required TResult Function(FieldValue_Array value) array,
  }) {
    return null_(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldValue_Null value)? null_,
    TResult? Function(FieldValue_String value)? string,
    TResult? Function(FieldValue_Int value)? int,
    TResult? Function(FieldValue_Bool value)? bool,
    TResult? Function(FieldValue_Float value)? float,
    TResult? Function(FieldValue_Array value)? array,
  }) {
    return null_?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldValue_Null value)? null_,
    TResult Function(FieldValue_String value)? string,
    TResult Function(FieldValue_Int value)? int,
    TResult Function(FieldValue_Bool value)? bool,
    TResult Function(FieldValue_Float value)? float,
    TResult Function(FieldValue_Array value)? array,
    required TResult orElse(),
  }) {
    if (null_ != null) {
      return null_(this);
    }
    return orElse();
  }
}

abstract class FieldValue_Null extends FieldValue {
  const factory FieldValue_Null() = _$FieldValue_NullImpl;
  const FieldValue_Null._() : super._();
}

/// @nodoc
abstract class _$$FieldValue_StringImplCopyWith<$Res> {
  factory _$$FieldValue_StringImplCopyWith(_$FieldValue_StringImpl value,
          $Res Function(_$FieldValue_StringImpl) then) =
      __$$FieldValue_StringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$FieldValue_StringImplCopyWithImpl<$Res>
    extends _$FieldValueCopyWithImpl<$Res, _$FieldValue_StringImpl>
    implements _$$FieldValue_StringImplCopyWith<$Res> {
  __$$FieldValue_StringImplCopyWithImpl(_$FieldValue_StringImpl _value,
      $Res Function(_$FieldValue_StringImpl) _then)
      : super(_value, _then);

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$FieldValue_StringImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$FieldValue_StringImpl extends FieldValue_String {
  const _$FieldValue_StringImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'FieldValue.string(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FieldValue_StringImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FieldValue_StringImplCopyWith<_$FieldValue_StringImpl> get copyWith =>
      __$$FieldValue_StringImplCopyWithImpl<_$FieldValue_StringImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(String field0) string,
    required TResult Function(int field0) int,
    required TResult Function(bool field0) bool,
    required TResult Function(double field0) float,
    required TResult Function(List<FieldValue> field0) array,
  }) {
    return string(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(String field0)? string,
    TResult? Function(int field0)? int,
    TResult? Function(bool field0)? bool,
    TResult? Function(double field0)? float,
    TResult? Function(List<FieldValue> field0)? array,
  }) {
    return string?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(String field0)? string,
    TResult Function(int field0)? int,
    TResult Function(bool field0)? bool,
    TResult Function(double field0)? float,
    TResult Function(List<FieldValue> field0)? array,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldValue_Null value) null_,
    required TResult Function(FieldValue_String value) string,
    required TResult Function(FieldValue_Int value) int,
    required TResult Function(FieldValue_Bool value) bool,
    required TResult Function(FieldValue_Float value) float,
    required TResult Function(FieldValue_Array value) array,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldValue_Null value)? null_,
    TResult? Function(FieldValue_String value)? string,
    TResult? Function(FieldValue_Int value)? int,
    TResult? Function(FieldValue_Bool value)? bool,
    TResult? Function(FieldValue_Float value)? float,
    TResult? Function(FieldValue_Array value)? array,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldValue_Null value)? null_,
    TResult Function(FieldValue_String value)? string,
    TResult Function(FieldValue_Int value)? int,
    TResult Function(FieldValue_Bool value)? bool,
    TResult Function(FieldValue_Float value)? float,
    TResult Function(FieldValue_Array value)? array,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }
}

abstract class FieldValue_String extends FieldValue {
  const factory FieldValue_String(final String field0) =
      _$FieldValue_StringImpl;
  const FieldValue_String._() : super._();

  String get field0;

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FieldValue_StringImplCopyWith<_$FieldValue_StringImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FieldValue_IntImplCopyWith<$Res> {
  factory _$$FieldValue_IntImplCopyWith(_$FieldValue_IntImpl value,
          $Res Function(_$FieldValue_IntImpl) then) =
      __$$FieldValue_IntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$FieldValue_IntImplCopyWithImpl<$Res>
    extends _$FieldValueCopyWithImpl<$Res, _$FieldValue_IntImpl>
    implements _$$FieldValue_IntImplCopyWith<$Res> {
  __$$FieldValue_IntImplCopyWithImpl(
      _$FieldValue_IntImpl _value, $Res Function(_$FieldValue_IntImpl) _then)
      : super(_value, _then);

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$FieldValue_IntImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$FieldValue_IntImpl extends FieldValue_Int {
  const _$FieldValue_IntImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'FieldValue.int(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FieldValue_IntImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FieldValue_IntImplCopyWith<_$FieldValue_IntImpl> get copyWith =>
      __$$FieldValue_IntImplCopyWithImpl<_$FieldValue_IntImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(String field0) string,
    required TResult Function(int field0) int,
    required TResult Function(bool field0) bool,
    required TResult Function(double field0) float,
    required TResult Function(List<FieldValue> field0) array,
  }) {
    return int(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(String field0)? string,
    TResult? Function(int field0)? int,
    TResult? Function(bool field0)? bool,
    TResult? Function(double field0)? float,
    TResult? Function(List<FieldValue> field0)? array,
  }) {
    return int?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(String field0)? string,
    TResult Function(int field0)? int,
    TResult Function(bool field0)? bool,
    TResult Function(double field0)? float,
    TResult Function(List<FieldValue> field0)? array,
    required TResult orElse(),
  }) {
    if (int != null) {
      return int(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldValue_Null value) null_,
    required TResult Function(FieldValue_String value) string,
    required TResult Function(FieldValue_Int value) int,
    required TResult Function(FieldValue_Bool value) bool,
    required TResult Function(FieldValue_Float value) float,
    required TResult Function(FieldValue_Array value) array,
  }) {
    return int(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldValue_Null value)? null_,
    TResult? Function(FieldValue_String value)? string,
    TResult? Function(FieldValue_Int value)? int,
    TResult? Function(FieldValue_Bool value)? bool,
    TResult? Function(FieldValue_Float value)? float,
    TResult? Function(FieldValue_Array value)? array,
  }) {
    return int?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldValue_Null value)? null_,
    TResult Function(FieldValue_String value)? string,
    TResult Function(FieldValue_Int value)? int,
    TResult Function(FieldValue_Bool value)? bool,
    TResult Function(FieldValue_Float value)? float,
    TResult Function(FieldValue_Array value)? array,
    required TResult orElse(),
  }) {
    if (int != null) {
      return int(this);
    }
    return orElse();
  }
}

abstract class FieldValue_Int extends FieldValue {
  const factory FieldValue_Int(final int field0) = _$FieldValue_IntImpl;
  const FieldValue_Int._() : super._();

  int get field0;

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FieldValue_IntImplCopyWith<_$FieldValue_IntImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FieldValue_BoolImplCopyWith<$Res> {
  factory _$$FieldValue_BoolImplCopyWith(_$FieldValue_BoolImpl value,
          $Res Function(_$FieldValue_BoolImpl) then) =
      __$$FieldValue_BoolImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool field0});
}

/// @nodoc
class __$$FieldValue_BoolImplCopyWithImpl<$Res>
    extends _$FieldValueCopyWithImpl<$Res, _$FieldValue_BoolImpl>
    implements _$$FieldValue_BoolImplCopyWith<$Res> {
  __$$FieldValue_BoolImplCopyWithImpl(
      _$FieldValue_BoolImpl _value, $Res Function(_$FieldValue_BoolImpl) _then)
      : super(_value, _then);

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$FieldValue_BoolImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$FieldValue_BoolImpl extends FieldValue_Bool {
  const _$FieldValue_BoolImpl(this.field0) : super._();

  @override
  final bool field0;

  @override
  String toString() {
    return 'FieldValue.bool(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FieldValue_BoolImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FieldValue_BoolImplCopyWith<_$FieldValue_BoolImpl> get copyWith =>
      __$$FieldValue_BoolImplCopyWithImpl<_$FieldValue_BoolImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(String field0) string,
    required TResult Function(int field0) int,
    required TResult Function(bool field0) bool,
    required TResult Function(double field0) float,
    required TResult Function(List<FieldValue> field0) array,
  }) {
    return bool(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(String field0)? string,
    TResult? Function(int field0)? int,
    TResult? Function(bool field0)? bool,
    TResult? Function(double field0)? float,
    TResult? Function(List<FieldValue> field0)? array,
  }) {
    return bool?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(String field0)? string,
    TResult Function(int field0)? int,
    TResult Function(bool field0)? bool,
    TResult Function(double field0)? float,
    TResult Function(List<FieldValue> field0)? array,
    required TResult orElse(),
  }) {
    if (bool != null) {
      return bool(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldValue_Null value) null_,
    required TResult Function(FieldValue_String value) string,
    required TResult Function(FieldValue_Int value) int,
    required TResult Function(FieldValue_Bool value) bool,
    required TResult Function(FieldValue_Float value) float,
    required TResult Function(FieldValue_Array value) array,
  }) {
    return bool(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldValue_Null value)? null_,
    TResult? Function(FieldValue_String value)? string,
    TResult? Function(FieldValue_Int value)? int,
    TResult? Function(FieldValue_Bool value)? bool,
    TResult? Function(FieldValue_Float value)? float,
    TResult? Function(FieldValue_Array value)? array,
  }) {
    return bool?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldValue_Null value)? null_,
    TResult Function(FieldValue_String value)? string,
    TResult Function(FieldValue_Int value)? int,
    TResult Function(FieldValue_Bool value)? bool,
    TResult Function(FieldValue_Float value)? float,
    TResult Function(FieldValue_Array value)? array,
    required TResult orElse(),
  }) {
    if (bool != null) {
      return bool(this);
    }
    return orElse();
  }
}

abstract class FieldValue_Bool extends FieldValue {
  const factory FieldValue_Bool(final bool field0) = _$FieldValue_BoolImpl;
  const FieldValue_Bool._() : super._();

  bool get field0;

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FieldValue_BoolImplCopyWith<_$FieldValue_BoolImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FieldValue_FloatImplCopyWith<$Res> {
  factory _$$FieldValue_FloatImplCopyWith(_$FieldValue_FloatImpl value,
          $Res Function(_$FieldValue_FloatImpl) then) =
      __$$FieldValue_FloatImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$FieldValue_FloatImplCopyWithImpl<$Res>
    extends _$FieldValueCopyWithImpl<$Res, _$FieldValue_FloatImpl>
    implements _$$FieldValue_FloatImplCopyWith<$Res> {
  __$$FieldValue_FloatImplCopyWithImpl(_$FieldValue_FloatImpl _value,
      $Res Function(_$FieldValue_FloatImpl) _then)
      : super(_value, _then);

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$FieldValue_FloatImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$FieldValue_FloatImpl extends FieldValue_Float {
  const _$FieldValue_FloatImpl(this.field0) : super._();

  @override
  final double field0;

  @override
  String toString() {
    return 'FieldValue.float(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FieldValue_FloatImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FieldValue_FloatImplCopyWith<_$FieldValue_FloatImpl> get copyWith =>
      __$$FieldValue_FloatImplCopyWithImpl<_$FieldValue_FloatImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(String field0) string,
    required TResult Function(int field0) int,
    required TResult Function(bool field0) bool,
    required TResult Function(double field0) float,
    required TResult Function(List<FieldValue> field0) array,
  }) {
    return float(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(String field0)? string,
    TResult? Function(int field0)? int,
    TResult? Function(bool field0)? bool,
    TResult? Function(double field0)? float,
    TResult? Function(List<FieldValue> field0)? array,
  }) {
    return float?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(String field0)? string,
    TResult Function(int field0)? int,
    TResult Function(bool field0)? bool,
    TResult Function(double field0)? float,
    TResult Function(List<FieldValue> field0)? array,
    required TResult orElse(),
  }) {
    if (float != null) {
      return float(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldValue_Null value) null_,
    required TResult Function(FieldValue_String value) string,
    required TResult Function(FieldValue_Int value) int,
    required TResult Function(FieldValue_Bool value) bool,
    required TResult Function(FieldValue_Float value) float,
    required TResult Function(FieldValue_Array value) array,
  }) {
    return float(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldValue_Null value)? null_,
    TResult? Function(FieldValue_String value)? string,
    TResult? Function(FieldValue_Int value)? int,
    TResult? Function(FieldValue_Bool value)? bool,
    TResult? Function(FieldValue_Float value)? float,
    TResult? Function(FieldValue_Array value)? array,
  }) {
    return float?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldValue_Null value)? null_,
    TResult Function(FieldValue_String value)? string,
    TResult Function(FieldValue_Int value)? int,
    TResult Function(FieldValue_Bool value)? bool,
    TResult Function(FieldValue_Float value)? float,
    TResult Function(FieldValue_Array value)? array,
    required TResult orElse(),
  }) {
    if (float != null) {
      return float(this);
    }
    return orElse();
  }
}

abstract class FieldValue_Float extends FieldValue {
  const factory FieldValue_Float(final double field0) = _$FieldValue_FloatImpl;
  const FieldValue_Float._() : super._();

  double get field0;

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FieldValue_FloatImplCopyWith<_$FieldValue_FloatImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FieldValue_ArrayImplCopyWith<$Res> {
  factory _$$FieldValue_ArrayImplCopyWith(_$FieldValue_ArrayImpl value,
          $Res Function(_$FieldValue_ArrayImpl) then) =
      __$$FieldValue_ArrayImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<FieldValue> field0});
}

/// @nodoc
class __$$FieldValue_ArrayImplCopyWithImpl<$Res>
    extends _$FieldValueCopyWithImpl<$Res, _$FieldValue_ArrayImpl>
    implements _$$FieldValue_ArrayImplCopyWith<$Res> {
  __$$FieldValue_ArrayImplCopyWithImpl(_$FieldValue_ArrayImpl _value,
      $Res Function(_$FieldValue_ArrayImpl) _then)
      : super(_value, _then);

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$FieldValue_ArrayImpl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<FieldValue>,
    ));
  }
}

/// @nodoc

class _$FieldValue_ArrayImpl extends FieldValue_Array {
  const _$FieldValue_ArrayImpl(final List<FieldValue> field0)
      : _field0 = field0,
        super._();

  final List<FieldValue> _field0;
  @override
  List<FieldValue> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'FieldValue.array(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FieldValue_ArrayImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FieldValue_ArrayImplCopyWith<_$FieldValue_ArrayImpl> get copyWith =>
      __$$FieldValue_ArrayImplCopyWithImpl<_$FieldValue_ArrayImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(String field0) string,
    required TResult Function(int field0) int,
    required TResult Function(bool field0) bool,
    required TResult Function(double field0) float,
    required TResult Function(List<FieldValue> field0) array,
  }) {
    return array(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(String field0)? string,
    TResult? Function(int field0)? int,
    TResult? Function(bool field0)? bool,
    TResult? Function(double field0)? float,
    TResult? Function(List<FieldValue> field0)? array,
  }) {
    return array?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(String field0)? string,
    TResult Function(int field0)? int,
    TResult Function(bool field0)? bool,
    TResult Function(double field0)? float,
    TResult Function(List<FieldValue> field0)? array,
    required TResult orElse(),
  }) {
    if (array != null) {
      return array(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FieldValue_Null value) null_,
    required TResult Function(FieldValue_String value) string,
    required TResult Function(FieldValue_Int value) int,
    required TResult Function(FieldValue_Bool value) bool,
    required TResult Function(FieldValue_Float value) float,
    required TResult Function(FieldValue_Array value) array,
  }) {
    return array(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FieldValue_Null value)? null_,
    TResult? Function(FieldValue_String value)? string,
    TResult? Function(FieldValue_Int value)? int,
    TResult? Function(FieldValue_Bool value)? bool,
    TResult? Function(FieldValue_Float value)? float,
    TResult? Function(FieldValue_Array value)? array,
  }) {
    return array?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FieldValue_Null value)? null_,
    TResult Function(FieldValue_String value)? string,
    TResult Function(FieldValue_Int value)? int,
    TResult Function(FieldValue_Bool value)? bool,
    TResult Function(FieldValue_Float value)? float,
    TResult Function(FieldValue_Array value)? array,
    required TResult orElse(),
  }) {
    if (array != null) {
      return array(this);
    }
    return orElse();
  }
}

abstract class FieldValue_Array extends FieldValue {
  const factory FieldValue_Array(final List<FieldValue> field0) =
      _$FieldValue_ArrayImpl;
  const FieldValue_Array._() : super._();

  List<FieldValue> get field0;

  /// Create a copy of FieldValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FieldValue_ArrayImplCopyWith<_$FieldValue_ArrayImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
